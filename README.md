# TEC-2 机急救手册

> 本资料整理自 TEC-2 实验机常见微指令序列和汇编程序，旨在以最小的代价完成实验报告或作业任务。所有内容基于已有指令组合，不涉及创造指令。

---

## 一、常用微指令对照表

| 微操作描述 | 微指令码 | 功能说明 |
|-----------|----------|---------|
| DR → AR | `0000 0E00 90B0 000A` | 将数据寄存器 DR 的内容送入地址寄存器 AR |
| SR → AR | `0000 0E00 90C0 0082` | 将源寄存器 SR 的内容送入 AR |
| MEM → Q | `0000 0E00 00F0 0000` | 从存储器读取数据到中间寄存器 Q |
| PC → AR, PC+1 → PC | `0000 0E00 A0B5 5402` | 取指阶段标准操作：PC 内容送 AR 并自动加 1 |
| MEM + Q → AR | `0000 0E00 10E0 0002` | 地址偏移计算：MEM + Q → AR |
| MEM + Q → Q | `0000 0E01 00E0 0000` | 执行加法：Q = Q + MEM |
| MEM - Q → Q | `0000 0E01 02E0 0000` | 执行减法：Q = MEM - Q |
| PC + 1 → AR | `0000 0E00 90B5 5402` | 将 PC+1 的结果送入 AR（用于预取） |
| MEM → AR | `0000 0E00 10F0 0002` | 从内存读出一个值作为地址送入 AR |
| MEM → R6 | `0000 0E00 30F0 6000` | 将内存数据加载到通用寄存器 R6 |
| R6 → MEM | `0029 0300 1046 0010` | 将 R6 的内容写入当前 AR 指向的内存单元 |
| R6 → AR, MEM → R6 | —— | 需分步执行：<br>先 `MEM → R6`<br>再 `R6 → AR` |
| Q → MEM, 条件 CC# = 0 | `0029 0300 1020 0010` | 若零标志 Z=1，则将 Q 写入内存 |
| Q → DR, 条件 CC# = 0 | `0029 0300 B020 0008` | 若零标志 Z=0，则将 Q 送入 DR |
| MEM + Q → DR, 条件 CC#=0, #3, A4H | `0029 0300 30E0 0008` | 在非零条件下执行加法并送 DR |

> **注**：  
> - 所有微指令均为 TEC-2 机已有控制字，不建议修改或自定义编码。  
> - `CC#` 字段控制条件执行：`0008` 表示 Z=0 时执行，`0010` 表示 Z=1 时执行。

---

## 二、自定义指令实现示例

### 指令 1：`D5DRSR, DISP`（双字指令）

- **指令格式**：`D5 DR SR, DISP`  
- **功能**：`(DR) ← (DR) - ((SR) + DISP)`  
- **控存入口地址**：`100H`（即 `0x0100`）  
- **说明**：从 `SR` 寄存器指向的内存地址开始，加上偏移量 `DISP`，取出该地址的值，与 `DR` 中的值相减，结果写回 `DR`。

#### 实现步骤

1. `SR → AR`：设置源地址
2. `MEM → Q`：读取 `(SR)` 的值
3. `PC+1 → PC, PC → AR`：取下一条指令（DISP）
4. `Q + MEM → AR`：计算 `(SR) + DISP` 得到有效地址
5. `MEM → Q`：读取该地址的值
6. `DR → AR`：准备读取 DR 原值
7. `MEM - Q → Q`：执行 `(DR) - ((SR)+DISP)`
8. `Q → DR, CC#=0`：结果写回 DR（无条件）

#### 微程序序列
```hex
0000 0E00 90C0 0082   ; SR -> AR
0000 0E00 00F0 0000   ; MEM -> Q
0000 0E00 A0B5 5402   ; PC -> AR, PC+1 -> PC (取 DISP)
0000 0E00 10E0 0002   ; Q + MEM -> AR (有效地址 = SR + DISP)
0000 0E00 00F0 0000   ; MEM -> Q (取 (SR+DISP))
0000 0E00 90B0 000A   ; DR -> AR (准备读 DR)
0000 0E01 02E0 0000   ; MEM - Q -> Q (DR - (SR+DISP))
0029 0300 B020 0008   ; Q -> DR, CC#=0 (写回 DR，Z=0 时执行)
```

#### 汇编测试代码
```asm
A800
MOV R1, 900
MOV R2, 8
MOV R3, 100
LDMC
RET
```

#### 测试程序
```asm
A820
MOV R0, 1100
MOV [1080], R0
MOV R0, 1070
MOV [1090], R0
MOV R0, 1050
MOV [1070], R0
MOV R0, 0001
MOV [1075], R0
MOV R0, 1080
MOV R1, 1090
NOP
NOP
RET
```

#### 测试输入
```bash
E834
D501 0005              ; R1 = R1 - ( [R1] + 5 )
G820
D1070                  ; 查看结果
```

---

### 指令 2：`D8DRSR, ADDR1, ADDR2`（三字指令）

- **指令格式**：`D8 DR SR, A1, A2`  
- **功能**：`(A1 + (DR)) ← (A2)`，即 `[A1 + DR] = [A2]`  
- **控存入口地址**：`110H`（即 `0x0110`）  
- **说明**：将地址 `A2` 处的值，写入到 `A1 + DR` 所指向的内存单元。

#### 实现步骤

1. `PC+1 → AR`：取第一个地址 A2
2. `MEM → AR`：A2 成为当前地址
3. `MEM → R6`：读取 `(A2)` 到 R6
4. `DR → AR`：准备取 DR 值
5. `MEM → Q`：读取 DR 的值
6. `PC → AR, PC+1 → PC`：取 A1
7. `MEM + Q → AR`：计算 `A1 + DR`
8. `R6 → MEM, CC#=0`：将 R6 内容写入目标地址

#### 微程序序列
```hex
0000 0E00 90B5 5402   ; PC+1 -> AR
0000 0E00 10F0 0002   ; MEM -> AR (A2)
0000 0E00 30F0 6000   ; MEM -> R6 (R6 = [A2])
0000 0E00 90B0 000A   ; DR -> AR
0000 0E00 00F0 0000   ; MEM -> Q (Q = DR)
0000 0E00 A0B5 5402   ; PC -> AR, PC+1 -> PC (取 A1)
0000 0E00 10E0 0002   ; MEM + Q -> AR (A1 + DR)
0029 0300 1046 0010   ; R6 -> MEM, CC#=0 (写入目标地址)
```

#### 汇编测试代码
```asm
A800
MOV R1, 900
MOV R2, 8
MOV R3, 110
LDMC
RET
```

#### 测试程序
```asm
A820
MOV R0, 1000
MOV R1, 0005
MOV [1000], R1
MOV [1020], R1
NOP
NOP
NOP
RET
```

#### 测试输入
```bash
E828
D801 1000 1020        ; 将 [1020] 的值写入 [1000 + R1] = [1005]
G820
D1000                 ; 查看 1000~1005 是否更新
```

---

### 指令 3：`E1DRSR, DISP`（双字指令）

- **指令格式**：`E1 DR SR, DISP`  
- **功能**：`if (DR == SR) then IP ← IP - DISP else 顺序执行`  
- **控存入口地址**：`130H`（即 `0x0130`）  
- **说明**：若 DR 与 SR 相等，则 IP 向后跳转 `DISP` 字节；否则顺序执行。

#### 实现步骤

1. `DR - SR`：比较 DR 与 SR，设置标志位
2. `PC → AR, PC+1 → PC`：取 DISP
3. `IP - DISP → IP, CC#=/Z`：若不相等则不跳（Z=0），否则跳转
4. `CC#=0`：继续执行

#### 微程序序列
```hex
0000 0E01 9190 0088   ; DR - SR (设置 Z 标志)
0000 0E00 A0B5 5402   ; PC -> AR, PC+1 -> PC (取 DISP)
0023 83E0 31D6 6000   ; IP - DISP -> IP, if Z=1 (相等则跳)
0029 0300 9080 0000   ; 继续执行（Z=0 时）
```

#### 汇编测试代码
```asm
A800
MOV R1, 900
MOV R2, 4
MOV R3, 130
LDMC
RET
```

#### 测试程序
```asm
A860
RET
MOV R0, 0001
MOV R1, 0001
NOP
NOP
MOV R7, 0007
MOV R8, 0008
RET
```

#### 测试输入
```bash
E865
E101 0020             ; 若 R0 == R1，则跳转 IP - 20H
G861
```

#### 调试过程
```text
>R
PC=0861 IP=0860 R0=0001 R1=0001
>T
PC=0863
>T
PC=0865
>T
PC=0845                ; 成功跳转（0865 - 20H = 0845）
```

> **结论**：当 `R0 == R1` 时发生跳转，验证条件转移功能正确。

---

## 三、常用命令与地址速查

| 命令 | 用途 |
|------|------|
| `A[addr]` | 设置汇编起始地址（如 A800） |
| `E[addr]` | 编辑微程序（如 E900） |
| `G[addr]` | 从指定地址运行程序 |
| `D[addr]` | 查看或输入内存数据 |
| `U[addr]` | 反汇编查看指令 |
| `R`     | 查看寄存器状态 |

---

## 四、使用说明

1. 所有微指令均来自已有定义，**不建议创造新编码**。
2. 自定义指令通过微程序控制实现，需正确设置 `LDMC` 参数（如 `MOV R3, 100` 对应 `D5` 指令）。
3. 指令跳转偏移为 **十六进制**，注意计算 `IP - DISP` 时的进制。
4. 调试时使用 `T` 单步执行，观察 `PC`、`IP`、`F` 标志变化。
